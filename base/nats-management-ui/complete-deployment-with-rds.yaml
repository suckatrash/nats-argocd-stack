# NATS Management UI - Complete Deployment with Cloud Database Support

This document provides complete configuration for the NATS Management UI with support for cloud databases (AWS RDS, GCP Cloud SQL, Azure Database).

## Architecture

```
┌──────────────────────────────────────────────┐
│         NATS Management UI Pod               │
│                                              │
│  ┌────────────────────────────────────────┐ │
│  │   Init Container (Secret Injection)    │ │
│  │   - Fetches DB credentials             │ │
│  │   - Generates config file               │ │
│  └────────────────────────────────────────┘ │
│                    ↓                         │
│  ┌────────────────────────────────────────┐ │
│  │   Main Container                       │ │
│  │   - Reads generated config             │ │
│  │   - Connects to NATS                   │ │
│  │   - Connects to cloud database         │ │
│  └────────────────────────────────────────┘ │
└──────────────────────────────────────────────┘
           ↓                      ↓
    ┌──────────┐           ┌─────────────┐
    │   NATS   │           │  Cloud DB   │
    │ Cluster  │           │   (RDS)     │
    └──────────┘           └─────────────┘
```

## Complete Deployment Manifest

```yaml
# base/nats-management-ui/complete-deployment.yaml
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nats-management-ui
  namespace: nats
  annotations:
    # AWS IRSA for RDS IAM authentication (optional)
    eks.amazonaws.com/role-arn: arn:aws:iam::ACCOUNT_ID:role/nats-management-rds-role
    # GCP Workload Identity
    iam.gke.io/gcp-service-account: nats-management@PROJECT_ID.iam.gserviceaccount.com

---
# ConfigMap with template (secrets will be injected)
apiVersion: v1
kind: ConfigMap
metadata:
  name: nats-management-config-template
  namespace: nats
data:
  config.json.template: |
    {
      "server": {
        "port": 8080,
        "host": "0.0.0.0"
      },
      "nats": {
        "url": "nats://nats.nats.svc.cluster.local:4222",
        "tls": {
          "enabled": true,
          "certFile": "/etc/nats-certs/tls.crt",
          "keyFile": "/etc/nats-certs/tls.key",
          "caFile": "/etc/nats-certs/ca.crt",
          "verify": true
        },
        "auth": {
          "username": "${NATS_USERNAME}",
          "password": "${NATS_PASSWORD}"
        }
      },
      "database": {
        "type": "${DB_TYPE}",
        "host": "${DB_HOST}",
        "port": ${DB_PORT},
        "database": "${DB_NAME}",
        "username": "${DB_USERNAME}",
        "password": "${DB_PASSWORD}",
        "sslMode": "${DB_SSL_MODE}",
        "maxConnections": 20,
        "connectionTimeout": 30
      },
      "monitoring": {
        "enabled": true,
        "metricsEndpoint": "http://mimir-query-frontend.mimir:8080"
      },
      "logging": {
        "level": "${LOG_LEVEL}",
        "format": "json"
      },
      "security": {
        "sessionSecret": "${SESSION_SECRET}",
        "jwtSecret": "${JWT_SECRET}"
      }
    }

---
# Secret from External Secrets Operator or Sealed Secrets
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: nats-management-secrets
  namespace: nats
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secretsmanager  # or gcp-secretmanager, azure-keyvault
    kind: SecretStore
  
  target:
    name: nats-management-secrets
    creationPolicy: Owner
  
  data:
  # NATS credentials
  - secretKey: nats-username
    remoteRef:
      key: nats/prod/credentials
      property: username
  
  - secretKey: nats-password
    remoteRef:
      key: nats/prod/credentials
      property: password
  
  # Database credentials
  - secretKey: db-host
    remoteRef:
      key: nats/prod/rds
      property: endpoint
  
  - secretKey: db-port
    remoteRef:
      key: nats/prod/rds
      property: port
  
  - secretKey: db-name
    remoteRef:
      key: nats/prod/rds
      property: database
  
  - secretKey: db-username
    remoteRef:
      key: nats/prod/rds
      property: username
  
  - secretKey: db-password
    remoteRef:
      key: nats/prod/rds
      property: password
  
  - secretKey: db-type
    remoteRef:
      key: nats/prod/rds
      property: type  # postgres, mysql, etc.
  
  - secretKey: db-ssl-mode
    remoteRef:
      key: nats/prod/rds
      property: sslMode  # require, verify-full, etc.
  
  # Application secrets
  - secretKey: session-secret
    remoteRef:
      key: nats/prod/app-secrets
      property: sessionSecret
  
  - secretKey: jwt-secret
    remoteRef:
      key: nats/prod/app-secrets
      property: jwtSecret

---
# Deployment with init container for config generation
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nats-management-ui
  namespace: nats
  labels:
    app: nats-management-ui
    app.kubernetes.io/name: nats-management-ui
    app.kubernetes.io/component: management
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: nats-management-ui
  template:
    metadata:
      labels:
        app: nats-management-ui
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: nats-management-ui
      
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 1000
        seccompProfile:
          type: RuntimeDefault
      
      # Init container to substitute secrets into config
      initContainers:
      - name: config-generator
        image: busybox:1.36
        command:
        - sh
        - -c
        - |
          set -e
          echo "Generating configuration from template..."
          
          # Export environment variables
          export NATS_USERNAME="$NATS_USERNAME"
          export NATS_PASSWORD="$NATS_PASSWORD"
          export DB_TYPE="$DB_TYPE"
          export DB_HOST="$DB_HOST"
          export DB_PORT="$DB_PORT"
          export DB_NAME="$DB_NAME"
          export DB_USERNAME="$DB_USERNAME"
          export DB_PASSWORD="$DB_PASSWORD"
          export DB_SSL_MODE="$DB_SSL_MODE"
          export SESSION_SECRET="$SESSION_SECRET"
          export JWT_SECRET="$JWT_SECRET"
          export LOG_LEVEL="${LOG_LEVEL:-info}"
          
          # Substitute variables in template
          envsubst < /config-template/config.json.template > /config-output/config.json
          
          # Verify JSON is valid
          cat /config-output/config.json | grep -q "database" || exit 1
          
          echo "Configuration generated successfully"
          
          # Optional: For RDS with IAM authentication
          if [ "$USE_RDS_IAM_AUTH" = "true" ]; then
            echo "Fetching RDS IAM auth token..."
            # This would require AWS CLI or similar in the image
            # TOKEN=$(aws rds generate-db-auth-token --hostname $DB_HOST --port $DB_PORT --username $DB_USERNAME)
            # sed -i "s|${DB_PASSWORD}|${TOKEN}|g" /config-output/config.json
          fi
        
        env:
        # NATS credentials
        - name: NATS_USERNAME
          valueFrom:
            secretKeyRef:
              name: nats-management-secrets
              key: nats-username
        - name: NATS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: nats-management-secrets
              key: nats-password
        
        # Database configuration
        - name: DB_TYPE
          valueFrom:
            secretKeyRef:
              name: nats-management-secrets
              key: db-type
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: nats-management-secrets
              key: db-host
        - name: DB_PORT
          valueFrom:
            secretKeyRef:
              name: nats-management-secrets
              key: db-port
        - name: DB_NAME
          valueFrom:
            secretKeyRef:
              name: nats-management-secrets
              key: db-name
        - name: DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: nats-management-secrets
              key: db-username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: nats-management-secrets
              key: db-password
        - name: DB_SSL_MODE
          valueFrom:
            secretKeyRef:
              name: nats-management-secrets
              key: db-ssl-mode
        
        # Application secrets
        - name: SESSION_SECRET
          valueFrom:
            secretKeyRef:
              name: nats-management-secrets
              key: session-secret
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: nats-management-secrets
              key: jwt-secret
        
        # Optional configuration
        - name: LOG_LEVEL
          value: "info"
        - name: USE_RDS_IAM_AUTH
          value: "false"
        
        volumeMounts:
        - name: config-template
          mountPath: /config-template
          readOnly: true
        - name: config
          mountPath: /config-output
        
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        
        resources:
          requests:
            cpu: 10m
            memory: 16Mi
          limits:
            cpu: 100m
            memory: 64Mi
      
      containers:
      # Main application container
      - name: nats-management-ui
        image: natsio/nats-surveyor:0.5.1  # Or your custom image
        imagePullPolicy: IfNotPresent
        
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        
        # If using custom application, modify command
        command:
        - /app/nats-management-ui
        args:
        - --config=/etc/app/config.json
        
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        - name: metrics
          containerPort: 9090
          protocol: TCP
        
        env:
        - name: CONFIG_PATH
          value: "/etc/app/config.json"
        
        volumeMounts:
        # Generated config with injected secrets
        - name: config
          mountPath: /etc/app
          readOnly: true
        
        # NATS TLS certificates
        - name: nats-certs
          mountPath: /etc/nats-certs
          readOnly: true
        
        # RDS CA certificate (for SSL/TLS)
        - name: rds-ca
          mountPath: /etc/ssl/certs/rds-ca.pem
          subPath: rds-ca.pem
          readOnly: true
        
        # Temp directory
        - name: tmp
          mountPath: /tmp
        
        # Cache directory
        - name: cache
          mountPath: /var/cache
        
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
            ephemeral-storage: 100Mi
          limits:
            cpu: 500m
            memory: 512Mi
            ephemeral-storage: 500Mi
        
        livenessProbe:
          httpGet:
            path: /healthz
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        
        readinessProbe:
          httpGet:
            path: /ready
            port: http
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        
        startupProbe:
          httpGet:
            path: /healthz
            port: http
          initialDelaySeconds: 0
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 30
      
      volumes:
      # Config template
      - name: config-template
        configMap:
          name: nats-management-config-template
      
      # Generated config (from init container)
      - name: config
        emptyDir:
          medium: Memory
      
      # NATS TLS certificates
      - name: nats-certs
        secret:
          secretName: nats-tls-cert
      
      # RDS CA certificate
      - name: rds-ca
        configMap:
          name: rds-ca-certificate
      
      # Temp directories
      - name: tmp
        emptyDir:
          medium: Memory
      - name: cache
        emptyDir:
          medium: Memory
      
      # Pod anti-affinity for HA
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  app: nats-management-ui
              topologyKey: kubernetes.io/hostname
          - weight: 50
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  app: nats-management-ui
              topologyKey: topology.kubernetes.io/zone
      
      # Node affinity (optional - for dedicated nodes)
      # nodeSelector:
      #   workload-type: application
      
      # Tolerations (optional)
      # tolerations:
      # - key: application
      #   operator: Equal
      #   value: "true"
      #   effect: NoSchedule

---
# Service
apiVersion: v1
kind: Service
metadata:
  name: nats-management-ui
  namespace: nats
  labels:
    app: nats-management-ui
spec:
  type: ClusterIP
  ports:
  - name: http
    port: 80
    targetPort: http
    protocol: TCP
  - name: metrics
    port: 9090
    targetPort: metrics
    protocol: TCP
  selector:
    app: nats-management-ui

---
# ServiceMonitor for Prometheus
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: nats-management-ui
  namespace: nats
  labels:
    app: nats-management-ui
    prometheus: kube-prometheus
spec:
  selector:
    matchLabels:
      app: nats-management-ui
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics

---
# Ingress
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nats-management-ui
  namespace: nats
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    # Rate limiting
    nginx.ingress.kubernetes.io/limit-rps: "10"
    # Timeout for database operations
    nginx.ingress.kubernetes.io/proxy-read-timeout: "300"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "300"
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - nats-ui.example.com
    secretName: nats-ui-tls
  rules:
  - host: nats-ui.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nats-management-ui
            port:
              number: 80

---
# HorizontalPodAutoscaler
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: nats-management-ui
  namespace: nats
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: nats-management-ui
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100
        periodSeconds: 30

---
# PodDisruptionBudget
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: nats-management-ui
  namespace: nats
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: nats-management-ui

---
# NetworkPolicy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: nats-management-ui
  namespace: nats
spec:
  podSelector:
    matchLabels:
      app: nats-management-ui
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # Allow from ingress controller
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 8080
  # Allow metrics scraping
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    ports:
    - protocol: TCP
      port: 9090
  egress:
  # Allow DNS
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
    ports:
    - protocol: UDP
      port: 53
  # Allow NATS connections
  - to:
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: nats
    ports:
    - protocol: TCP
      port: 4222
  # Allow RDS connections (adjust CIDR as needed)
  - to:
    - ipBlock:
        cidr: 10.0.0.0/8  # Your VPC CIDR
    ports:
    - protocol: TCP
      port: 5432  # PostgreSQL
    - protocol: TCP
      port: 3306  # MySQL
  # Allow HTTPS to external services
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0
        except:
        - 169.254.169.254/32  # Block metadata service
    ports:
    - protocol: TCP
      port: 443
```

This deployment includes:

1. **Secret Injection**: Init container that substitutes environment variables into config
2. **Cloud Database Support**: RDS, Cloud SQL, Azure Database
3. **NATS Connection**: With TLS certificates
4. **Security**: NetworkPolicy, SecurityContext, RBAC
5. **High Availability**: Multiple replicas, PDB, anti-affinity
6. **Auto-scaling**: HPA based on CPU/memory
7. **Monitoring**: ServiceMonitor for Prometheus
8. **Health Checks**: Liveness, readiness, startup probes

The secrets are fetched from your cloud secret manager (AWS Secrets Manager, GCP Secret Manager, or Azure Key Vault) using External Secrets Operator, then injected into the configuration file at runtime.
