---
# Job to generate and rotate Cloud SQL client certificates
# Runs after Database and User are ready (wave 2)
# Automatically rotates certificates expiring within 90 days
apiVersion: batch/v1
kind: Job
metadata:
  name: generate-db-client-cert
  namespace: control-plane
  annotations:
    argocd.argoproj.io/sync-wave: "2"
spec:
  # Clean up completed jobs after 1 hour
  ttlSecondsAfterFinished: 3600
  template:
    spec:
      restartPolicy: OnFailure
      serviceAccountName: secret-generator
      containers:
      - name: generate-cert
        image: google/cloud-sdk:alpine
        command:
        - /bin/sh
        - -c
        - |
          set -e

          # Get project ID from metadata server
          echo "Fetching project ID from metadata server..."
          PROJECT_ID=$(curl -H "Metadata-Flavor: Google" "http://metadata.google.internal/computeMetadata/v1/project/project-id" 2>/dev/null || echo "")

          if [ -z "$PROJECT_ID" ]; then
            echo "Error: Could not retrieve project ID from metadata server"
            exit 1
          fi

          echo "Using project: $PROJECT_ID"

          # Install required tools
          apk add --no-cache kubectl coreutils

          INSTANCE_NAME="control-plane-db"
          CERT_NAME="control-plane-client-cert"
          SECRET_NAME="control-plane-db-client-certs"
          NAMESPACE="control-plane"
          ROTATION_THRESHOLD_DAYS=90

          # Function to create a new certificate
          create_certificate() {
            local cert_name=$1
            local cert_dir=$2

            echo "Creating client certificate: $cert_name..."

            # Create the certificate and get the private key
            gcloud sql ssl client-certs create $cert_name \
              $cert_dir/client-key.pem \
              --instance=$INSTANCE_NAME \
              --project=$PROJECT_ID

            # Download the client certificate
            gcloud sql ssl client-certs describe $cert_name \
              --instance=$INSTANCE_NAME \
              --project=$PROJECT_ID \
              --format="get(cert)" > $cert_dir/client-cert.pem

            # Download the server CA certificate
            echo "Downloading server CA certificate..."
            gcloud sql ssl server-ca-certs list \
              --instance=$INSTANCE_NAME \
              --project=$PROJECT_ID \
              --limit=1 \
              --format="get(cert)" > $cert_dir/server-ca.pem

            # Verify files exist and have content
            for file in client-key.pem client-cert.pem server-ca.pem; do
              if [ ! -s "$cert_dir/$file" ]; then
                echo "ERROR: $file was not created or is empty"
                return 1
              fi
              echo "$file created successfully ($(wc -c < $cert_dir/$file) bytes)"
            done

            return 0
          }

          # Check if secret already exists
          echo "Checking if client certificate secret exists..."
          SECRET_EXISTS=false
          if kubectl get secret $SECRET_NAME -n $NAMESPACE &>/dev/null; then
            SECRET_EXISTS=true
            echo "Secret exists"
          else
            echo "Secret does not exist"
          fi

          # Check if certificate exists in Cloud SQL and get expiration
          # Look for any certificate starting with our prefix (handles timestamped rotations)
          echo "Checking existing certificates in Cloud SQL..."
          EXISTING_CERT=$(gcloud sql ssl client-certs list \
            --instance=$INSTANCE_NAME \
            --project=$PROJECT_ID \
            --format="value(commonName)" \
            --filter="commonName:$CERT_NAME*" 2>/dev/null | head -1 || echo "")

          NEEDS_ROTATION=false
          REASON=""

          if [ -n "$EXISTING_CERT" ]; then
            echo "Certificate $EXISTING_CERT exists in Cloud SQL"

            # Get expiration time (RFC 3339 format)
            EXPIRATION=$(gcloud sql ssl client-certs describe $EXISTING_CERT \
              --instance=$INSTANCE_NAME \
              --project=$PROJECT_ID \
              --format="get(expirationTime)" 2>/dev/null || echo "")

            if [ -z "$EXPIRATION" ]; then
              echo "WARNING: Could not retrieve expiration time"
              NEEDS_ROTATION=true
              REASON="cannot determine expiration"
            else
              echo "Certificate expires: $EXPIRATION"

              # Convert expiration to epoch seconds
              # Format: 2025-11-14T16:42:48.000Z -> parse with date
              EXPIRATION_EPOCH=$(date -d "$EXPIRATION" +%s 2>/dev/null || echo "0")
              CURRENT_EPOCH=$(date +%s)
              THRESHOLD_EPOCH=$((CURRENT_EPOCH + ROTATION_THRESHOLD_DAYS * 86400))

              if [ "$EXPIRATION_EPOCH" -eq 0 ]; then
                echo "WARNING: Could not parse expiration time"
                NEEDS_ROTATION=true
                REASON="cannot parse expiration time"
              elif [ "$EXPIRATION_EPOCH" -lt "$CURRENT_EPOCH" ]; then
                echo "Certificate has EXPIRED"
                NEEDS_ROTATION=true
                REASON="expired"
              elif [ "$EXPIRATION_EPOCH" -lt "$THRESHOLD_EPOCH" ]; then
                DAYS_UNTIL_EXPIRY=$(( (EXPIRATION_EPOCH - CURRENT_EPOCH) / 86400 ))
                echo "Certificate expires in $DAYS_UNTIL_EXPIRY days (threshold: $ROTATION_THRESHOLD_DAYS days)"
                NEEDS_ROTATION=true
                REASON="expires in $DAYS_UNTIL_EXPIRY days"
              else
                DAYS_UNTIL_EXPIRY=$(( (EXPIRATION_EPOCH - CURRENT_EPOCH) / 86400 ))
                echo "Certificate is valid for $DAYS_UNTIL_EXPIRY more days"
                NEEDS_ROTATION=false
              fi
            fi
          else
            echo "Certificate does not exist in Cloud SQL"
            if [ "$SECRET_EXISTS" = true ]; then
              echo "WARNING: Secret exists but Cloud SQL certificate is missing"
              NEEDS_ROTATION=true
              REASON="certificate missing from Cloud SQL"
            else
              echo "First-time certificate creation needed"
              NEEDS_ROTATION=true
              REASON="initial creation"
            fi
          fi

          # Decide action
          if [ "$NEEDS_ROTATION" = false ] && [ "$SECRET_EXISTS" = true ]; then
            echo "Certificate is valid and secret exists, no action needed"
            exit 0
          fi

          # Special case: Certificate exists but secret is missing
          # We cannot retrieve the private key, so we must delete and recreate
          if [ -n "$EXISTING_CERT" ] && [ "$SECRET_EXISTS" = false ]; then
            echo "WARNING: Certificate exists but Kubernetes secret is missing"
            echo "Cannot retrieve private key from Cloud SQL - must recreate certificate"
            NEEDS_ROTATION=true
            REASON="secret missing (orphaned certificate)"
          fi

          if [ "$NEEDS_ROTATION" = true ]; then
            echo "Certificate rotation needed: $REASON"
          else
            echo "Certificate creation needed"
          fi

          # Create temporary directory for new certificate
          CERT_DIR=$(mktemp -d)

          # Rotate certificate if needed
          if [ "$NEEDS_ROTATION" = true ] && [ -n "$EXISTING_CERT" ]; then
            # Create new certificate with timestamp suffix
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            NEW_CERT_NAME="${CERT_NAME}-${TIMESTAMP}"

            echo "Creating new certificate: $NEW_CERT_NAME"
            if ! create_certificate "$NEW_CERT_NAME" "$CERT_DIR"; then
              echo "ERROR: Failed to create new certificate"
              rm -rf $CERT_DIR
              exit 1
            fi

            # Update or create Kubernetes secret with new certificate
            echo "Updating Kubernetes secret with new certificate..."
            kubectl create secret generic $SECRET_NAME \
              -n $NAMESPACE \
              --from-file=client-key.pem=$CERT_DIR/client-key.pem \
              --from-file=client-cert.pem=$CERT_DIR/client-cert.pem \
              --from-file=server-ca.pem=$CERT_DIR/server-ca.pem \
              --dry-run=client -o yaml | kubectl apply -f -

            # Delete old certificate from Cloud SQL
            echo "Deleting old certificate: $EXISTING_CERT"
            gcloud sql ssl client-certs delete $EXISTING_CERT \
              --instance=$INSTANCE_NAME \
              --project=$PROJECT_ID \
              --quiet || echo "WARNING: Failed to delete old certificate (may already be deleted)"

            echo "Certificate rotated successfully: $EXISTING_CERT -> $NEW_CERT_NAME"
            echo "Note: Old certificate deleted, new timestamped certificate is active"

          else
            # First-time creation
            echo "Creating initial certificate..."
            if ! create_certificate "$CERT_NAME" "$CERT_DIR"; then
              echo "ERROR: Failed to create certificate"
              rm -rf $CERT_DIR
              exit 1
            fi

            # Create Kubernetes secret
            echo "Creating Kubernetes secret with client certificates..."
            kubectl create secret generic $SECRET_NAME \
              -n $NAMESPACE \
              --from-file=client-key.pem=$CERT_DIR/client-key.pem \
              --from-file=client-cert.pem=$CERT_DIR/client-cert.pem \
              --from-file=server-ca.pem=$CERT_DIR/server-ca.pem

            echo "Client certificate created successfully"
          fi

          # Clean up temporary files
          rm -rf $CERT_DIR

          echo "Certificate management completed successfully"
